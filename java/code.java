//주석처리 : Ctrl+/

// //======================================================================
// // &&, || / and, or 연산자 문제
// import java.util.Scanner;

// public class Main {
//     public static void main(String[] args) {

//         Scanner scan = new Scanner(System.in);

//         int x = scan.nextInt();
        
//         // && : 좌측값이 true면 우측값 반환, 좌측값이 false면 좌측값 반환
//         // || : 좌측값이 true면 좌측값 반환, 좌측값이 false면 좌측값 반환
        
//         if ( (x%400==0) || (x%100!=0) && (x%4==0) ) {
//             System.out.println("1");
//         } else {
//             System.out.println("0");
//         }

//         scan.close();
//     }
// }
// 

// //======================================================================
// // &&, || / and, or 연산자 문제























// //======================================================================
// // n-queen 문제
// public class Main {
//     public static void main(String[] args) {
//         int count = 0;

//         int i_print = 1;
//         long data = 257948135L;
//         int i_break = 0;

//         while (data <= 9876543210L) {
//             /*
//              * 행열검사
//              * 조건 검사 : 자릿수 거리 차이[data,i2차이]=값 차이[board[data],board[i2]차이]
//              * 검사 횟수 : (n+1)*n/2 > 시간 복잡도 n^2
//              */
//             long a = 1L;
//             int a_dig = 1;
//             while (a < 876543210L && i_break < 1) { // 98억 7654만 3210원 a는 1~1억, b는 10~10억
//                 long b = a;
//                 int b_dig = a_dig;
//                 while (b < 876543210L && i_break < 1) { // b 1억까지
//                     b = b * 10;
//                     b_dig++;
//                     long c1 = data/a%10;
//                     long c2 = data/b%10;
//                     if ( ( c1==c2 ) || ((a_dig-b_dig) == (c1-c2)) || ((a_dig-b_dig) == (c2-c1)) ) { //
//                         i_break = 1;
//                         i_print = 0;
//                     }
//                 }
//                 a = a * 10;
//                 a_dig++;
//             }
//             i_break = 0;

//             // 출력
//             if (i_print > 0) {
//                 if (data < 1000000000) {
//                     System.out.print("0");
//                 }
//                 count++;
//                 System.out.println(data+"$");
//             }
//             // 반복 실행 특정인자 수정
//             data++;
//             i_print = 1;
//         }
//         System.out.println(count);
//     }
// }

/*
 * 0257948136
 * n의 자릿수는 [거리=높이] 값이 있으면 안된다.
 * 거리=높이 > n과 자릿수 차이=값의 차이
 * 
 * 한자리에 하나의 수만 뽑으면
 * > 어차피 10 by 10에 10개라 [행열 중복 x조건]이 만족
 * 그렇다면 0~9를 배열에 넣고 순서만 바꾸면서
 * [자릿수 거리 차이=값 차이]이 아닌 조건만 충족한걸 찾는다!
 * 0123456789 ori --
 * 0123456798 ori, n&n-1
 * 0123456879 ori, n-1&n-2
 * 0123456897 ori, n-1&n-2, n&n-1
 * 0123456978 ori, n&n-2,
 * 0123456987 ori,
 * 0123457689 ori, n-2&n-3
 * 0123457698 ori, n-2&n-3, n&n-1
 * 0123457869 ori, n-2&n-3, n-1&n-2
 * 0123457896 ori, n-2&n-3, n-1&n-2, n&n-1
 * 0123457968 ori, n-2&n-3, n-2&n
 * 0123457986 ori, n-2&n-3, n-2&n, n&n-1
 * 0123458679
 * 0123458697
 * 0123458769
 * 0123458796
 * 
 * [1][2] 1*2
 * [2][1]
 * [1][2][3] 1*2*3
 * [1][3][2]
 * [2][1][3]
 * [2][3][1]
 * [3][1][2]
 * [3][2][1]
 * [1][2][3][4] 1*2*3*4
 * [1][2][4][3]
 * [1][3][2][4]
 * [1][3][4][2]...함수안 함수안 함수...10*9*7*6..
 * 
 * 숫자생성&행열검사생략 but 제작 시간 복잡도 n!
 * > 그냥 하나씩 직접 뽑자 야밤
 * 행열 중복된 숫자 직접 검사 구문 = 시간 복잡도 55n
 */
